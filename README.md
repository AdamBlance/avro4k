# <img src="src/main/graphics/logo.png" height=160>
[Avro](https://avro.apache.org/) format for [kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization). This library is a port of my Scala Avro generator [avro4s](https://github.com/sksamuel/avro4s).

[![Build Status](https://travis-ci.org/sksamuel/avro4k.svg?branch=master)](https://travis-ci.org/sksamuel/avro4k)
[<img src="https://img.shields.io/maven-central/v/com.sksamuel.avro4k/avro4k.svg?label=latest%20release"/>](http://search.maven.org/#search%7Cga%7C1%7Cavro4k)
[<img src="https://img.shields.io/nexus/s/https/oss.sonatype.org/com.sksamuel.avro4k/avro4k.svg?label=latest%20snapshot&style=plastic"/>](https://oss.sonatype.org/content/repositories/snapshots/com/sksamuel/avro4k/)

## Schemas

Unlike say Json, Avro is a schema based format. You'll find yourself wanting to generate schemas frequently, and writing these by hand or through the Java based `SchemaBuilder` classes can be tedious for complex domain models. Avro4k allows us to generate schemas directly from data classes at compile time using the Kotlin Serialization library. This gives you both the convenience of generated code, without the annoyance of having to run a code generation step, as well as avoiding the peformance penalty of runtime reflection based code.

Let's define some classes.

```kotlin
@Serializable
data class Ingredient(val name: String, val sugar: Double, val fat: Double)

@Serializable
data class Pizza(val name: String, val ingredients: List<Ingredient>, val vegetarian: Boolean, val kcals: Int)
```

To generate an Avro Schema, we need to use the `Avro` object, invoking `schema` and passing in the serializer generated by the Kotlin Serialization compiler plugin for your target class. This will return an `org.apache.avro.Schema` instance.

In other words:

```kotlin
import com.sksamuel
val schema = Avro.default.schema(Pizza.serializer())
```

Where the generated schema is as follows:

```json
{
   "type":"record",
   "name":"Pizza",
   "namespace":"com.sksamuel",
   "fields":[
      {
         "name":"name",
         "type":"string"
      },
      {
         "name":"ingredients",
         "type":{
            "type":"array",
            "items":{
               "type":"record",
               "name":"Ingredient",
               "fields":[
                  {
                     "name":"name",
                     "type":"string"
                  },
                  {
                     "name":"sugar",
                     "type":"double"
                  },
                  {
                     "name":"fat",
                     "type":"double"
                  }
               ]
            }
         }
      },
      {
         "name":"vegetarian",
         "type":"boolean"
      },
      {
         "name":"kcals",
         "type":"int"
      }
   ]
}
```
You can see that the schema generator handles nested data classes, lists, primitives, etc. For a full list of supported object types, see the table later.

### Adding properties and docs to a Schema

Avro allows a doc field, and arbitrary key/values to be added to generated schemas.
Avro4k supports this through the use of `@AvroDoc` and `@AvroProp` annotations.

These properties works on either complex or simple types - in other words, on both fields and classes. 

For example, the following code:

```kotlin
package com.sksamuel

@Serializable
@AvroDoc("hello, is it me you're looking for?")
data class Foo(@AvroDoc("I am a string")  val str: String, 
               @AvroDoc("I am a long")    val long: Long, 
                                          val int: Int)
```

Would result in the following schema:

```json
{  
  "type": "record",
  "name": "Foo",
  "namespace": "com.sksamuel",
  "doc":"hello, is it me you're looking for?",
  "fields": [  
    {  
      "name": "str",
      "type": "string",
      "doc" : "I am a string"
    },
    {  
      "name": "long",
      "type": "long",
      "doc" : "I am a long"
    },
    {  
      "name": "int",
      "type": "int"
    }
  ]
}
```

Similarly, for properties:

```kotlin
package com.sksamuel

@Serializable
@AvroProp("jack", "bruce")
data class Annotated(@AvroProp("richard", "ashcroft") val str: String, 
                     @AvroProp("kate", "bush")        val long: Long, 
                                                      val int: Int)
```

Would generate this schema:

```json
{
  "type": "record",
  "name": "Annotated",
  "namespace": "com.sksamuel",
  "fields": [
    {
      "name": "str",
      "type": "string",
      "richard": "ashcroft"
    },
    {
      "name": "long",
      "type": "long",
      "kate": "bush"
    },
    {
      "name": "int",
      "type": "int"
    }
  ],
  "jack": "bruce"
}
```

### Decimal scale and precision

In order to customize the scale and precision used by BigDecimal schema generators, 
you can add the `@ScalePrecision` annotation to instances of BigDecimal.

For example, this code:

```kotlin
@Serializable
data class Test(@ScalePrecision(1, 4) val decimal: BigDecimal)

val schema = Avro.default.schema(Test.serializer())
```

Would generate the following schema:

```json
{
  "type":"record",
  "name":"Test",
  "namespace":"com.foo",
  "fields":[{
    "name":"decimal",
    "type":{
      "type":"bytes",
      "logicalType":"decimal",
      "scale":"1",
      "precision":"4"
    }
  }]
}
```

### Avro Fixed

Avro supports the idea of fixed length byte arrays.
To use these we can either override the schema generated for a type to return Schema.Type.Fixed. 
This will work for types like String or UUID. 
You can also annotate a field with `@AvroFixed(size)`. 

For example:

```kotlin
package com.sksamuel

data class Foo(@AvroFixed(7) val mystring: String)

val schema = Avro.default.schema(Foo.serializer())
```

Will generate the following schema:

```json
{
  "type": "record",
  "name": "Foo",
  "namespace": "com.sksamuel",
  "fields": [
    {
      "name": "mystring",
      "type": {
        "type": "fixed",
        "name": "mystring",
        "size": 7
      }
    }
  ]
}
```

If you have a type that you always want to be represented as fixed, then rather than annotate every single location
 it is used, you can annotate the type itself.

```kotlin
package com.sksamuel

@AvroFixed(4)
@Serializable
data class FixedA(val bytes: ByteArray)

@Serializable
data class Foo(val a: FixedA)

val schema = Avro.default.schema(Foo.serializer())
```

And this would generate:

```json
{
  "type": "record",
  "name": "Foo",
  "namespace": "com.sksamuel",
  "fields": [
    {
      "name": "a",
      "type": {
        "type": "fixed",
        "name": "FixedA",
        "size": 4
      }
    }
  ]
}
```

### Using avro4s in your project

Gradle
```compile 'com.sksamuel.avro4k:avro4k:xxx'```

Maven
```xml
<dependency>
    <groupId>com.sksamuel.avro4k</groupId>
    <artifactId>avro4k</artifactId>
    <version>xxx</version>
</dependency>
```

Check the latest released version on Maven Central

###Contributions

Contributions to avro4s are always welcome. Good ways to contribute include:

- Raising bugs and feature requests
- Fixing bugs and enhancing the DSL
- Improving the performance of avro4k
= Adding to the documentation